<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="icon" type="image/x-icon" href="/images/uil.ico">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/styles/styles.css">
<link rel="stylesheet" href="/styles/atom-one-dark.min.css">
<script src="/scripts/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
    <title>Big O Notation</title>
</head>
<body>
    <div class="body">
        <ul class="navbar">
            <div class="title">
                <li>
                    <a href="/">Home</a>
                </li>
            </div>
            <div>
                <li><a href="/concepts">Concepts</a></li>
            </div>
        </ul>
    
        <div class="sidenav">
            <a href="#title">Big O Notation</a>
            <ul>
                <li><a href="#video">Video</a></li>
                <li><a href="#explanation">Explanation</a></li>
                <li><a href="#O(1)">O(1)</a></li>
                <li><a href="#O(logn)">O(logn)</a></li>
                <li><a href="#practice">Practice</a></li>
            </ul>
        </div>
        
        <div class="content">
            <h1 id="title">Big O Notation</h1>
            <h2>Difficulty <em>medium</em></h2>
            <p>Before reading, it is necessary to watch this video: 
                <div class="iframe-container">
                    <br><br><iframe width="560" height="315" id="video" src="https://www.youtube.com/embed/__vX2sjlpXU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br><br>
                </div>
            <br><p id="explanation">Big O is basically a measure of an algorithim's complexity in terms of N. It has nothing to do with the hardware running the code. It can be looked at 
            in worst-case, best-case, and average-case, but you'll only be needing to learn worst-case. Two things to note about Big O are:</p>
            <ul>
                <li>Big O ignores constants. For instance, 5n is written as O(n)</li>
                <li>Higher order terms take precedence over lower terms. The highest order term is the complexity of the code.
                    <ul>
                        <li>O(2ⁿ)</li>
                        <li>O(n²)</li>
                        <li>O(nlogn)</li>
                        <li>O(n)</li>
                        <li>O(logn)</li>
                        <li>O(1)</li>
                    </ul>
                </li>
            </ul>

            <p>Let's take a look at what these different terms mean.</p>

            <h2 id="O(1)">O(1)</h2>

            <p>O(1) means that the program has a constant time regardless of the data set size. They are efficient with any data set.
            Take this code for example:</p>

            <pre><code>int i = 3;
    System.out.println(i);</code></pre>

            <p>No matter how big the int we print, or how many print statements we have, the input never changes the execution time. Therefore, it is O(1).</p>
            
            <br>
            
            <h2 id="O(logn)">O(logn)</h2>

            <p>O(logn) means that the amount of data an algorithm has is halved each time it runs, or passes. They are efficient with large data sets.
            This can be very easily visualized with a binary search tree.</p>

            <img src="/images/binary search tree.png" alt="Image of a binary search tree" class="responsive">

            <p>Each time you branch off from one number to another and proceed down the tree, you are halving your data set. Binary search trees are not the only
            algorithms with logn complexities. Another example, shockingly, is a logarithm.
            <br>In order to this next example, we must first understand what a log is. A log is the exponent
            or power to which another number needs to be raised to yield a certain number. In computer science, it is assumed that the base of a log is 2, so 
            let's say we need to find x when log₂8=x. This problem is asking for the exponent that needs to be applied on 2 to equal 8 
            which can be rewritten as 2ˣ=8. With this in mind, let's take a look at this code:</p>

            <pre><code>import static java.lang.System.*;
    public class test{
        public static void main (String[] args){
            double n = 8.0;
            out.println(log(n));
        }
        public static double log(double n){
            if(n == 0){
                return n;
            } 
            n=Math.floor(n/2);
            return log(n);
        }
    }</code></pre>
            <p>In the program, the main method asks to print out log(8). The method first checks to see if the input is equal to 0 and simply returns 0 if it is.
            If it isn't, it divides n by 2, and then rounds it down to avoid dealing with decimals. Finally, it calls itself again in what is known as a recursion
            and the process is repeated until 0 is reached. Notice that this program runs 3 times before returning 0 which is the answer to the problem we discussed earlier.
            This code also has a complexity of O(logn) because the data set is halved every pass.
            </p>
            <br><br>

            <div class="iframe-container" id="practice">
                <iframe src="https://docs.google.com/forms/d/e/1FAIpQLSfzDT_b_bmFDMFfrelPeW1j47FKoprXbi07UpjdZq6s1KrFzw/viewform?embedded=true" width="640" height="360" frameborder="0" marginheight="0" marginwidth="0">Loading…</iframe>
            </div>
        </div>
    </div>
</body>
</html>